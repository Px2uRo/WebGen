using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Linq;

namespace MySourceGen
{
    [Generator]
    public class HandleControllerAtrribute : ISourceGenerator
    {
        GeneratorExecutionContext context;
        private List<string> g_clsN = new();

        public void Execute(GeneratorExecutionContext context)
        {
            this.context= context;
            var controllers = ControllerCollector.CollectControllers(context);
            var gfc = GenFakeControllers(controllers);
            var ns = "MySourceGen.AutoGen";
            var mU = new HashSet<string>
    {
        "System",
        "System.Text",
        "Microsoft.AspNetCore.Builder",
        "Microsoft.AspNetCore.Mvc"
    };

            // 合并所有 using 指令并去重
            var meU = mU.Union(CollectAllUsings(controllers))
                                        .OrderBy(u => u.StartsWith("System") ? 0 : 1)
                                        .ThenBy(u => u);
            var cU = meU.Union( GetContextUsings(context)).OrderBy(u => u.StartsWith("System") ? 0 : 1).ThenBy(u => u);
            var usingsSection = string.Join("\n",cU.Select(u => $"using {u};"));

            var source = $$"""
            /*<autogenerated>
            该代码于{{DateTime.Now.ToString("R")}}用 MyCodeGen 生成
            找到了个{{controllers.Count}}控制器标签
            不要更改这里的代码，更改之后的代码不会被保存。
            </autogenerated>*/

            {{usingsSection}}

            namespace {{ns}}
            {
                {{gfc}}
                public static class ReMapUtil
                {
                    public static void ReMap(this Microsoft.AspNetCore.Builder.WebApplication app)
                    {
                        {{GenMinimalMapping(controllers)}}
                    }
                }
            }
            """;


            context.AddSource("ReMap.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private List<string> GetContextUsings(GeneratorExecutionContext context)
        {
            var res = new List<string>();
            foreach (var tree in context.Compilation.SyntaxTrees)
            {
                var root = tree.GetRoot() as CompilationUnitSyntax;
                var namespaceDecl = root.Members
                    .OfType<NamespaceDeclarationSyntax>()
                    .FirstOrDefault();

                if (namespaceDecl != null)
                {
                    string namespaceName = namespaceDecl.Name.ToString();
                    res.Add(namespaceName);
                }
            }
            return res;
        }

        private string GenFakeControllers(Dictionary<ClassDeclarationSyntax, SyntaxTree> controllers)
        {
            var sb = new StringBuilder();
            foreach (var kvp in controllers)
            {

                var conDe = kvp.Key;
                var tree = kvp.Value;
                var model = context.Compilation.GetSemanticModel(controllers[conDe]);
                var controllerName = conDe.Identifier.Text.Replace("Controller", "");
                var conSym = model.GetDeclaredSymbol(conDe) as INamedTypeSymbol;


                string baseRoute = conDe.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Where(attr =>
                    {
                        var sym = model.GetSymbolInfo(attr).Symbol as IMethodSymbol;
                        return sym?.ContainingType.ToDisplayString() == "Microsoft.AspNetCore.Mvc.RouteAttribute";
                    })
                    .Select(attr =>
                    {
                        var argExpr = attr.ArgumentList?.Arguments.FirstOrDefault()?.Expression;
                        var constVal = argExpr != null ? model.GetConstantValue(argExpr) : default;
                        if (constVal.HasValue && constVal.Value is string route)
                            return route;
                        return null;
                    })
                    .FirstOrDefault() ?? controllerName;

                var modi = string.Join(" " ,conDe.Modifiers.Select(x=>x.Text));
                var cln = "g_"+conDe.Identifier.Text;
                this.g_clsN.Add(cln);
                List<string> bstC = new List<string>();
                bstC.Add(conSym.BaseType.ToDisplayString());
                bstC.AddRange(conSym.Interfaces.Select(x => x.ToDisplayString()));
                var baseTy = string.Join(",", bstC);
                conDe.BaseList.ToString();
                #region ControllerName处理

                // 解析 Controller 的 [Route]，默认为 controllerName
                string prfx = conDe.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Where(attr =>
                    {
                        var sym = model.GetSymbolInfo(attr).Symbol as IMethodSymbol;
                        return sym?.ContainingType.ToDisplayString() == "Microsoft.AspNetCore.Mvc.RouteAttribute";
                    })
                    .Select(attr =>
                    {
                        var argExpr = attr.ArgumentList?.Arguments.FirstOrDefault()?.Expression;
                        var constVal = argExpr != null ? model.GetConstantValue(argExpr) : default;
                        if (constVal.HasValue && constVal.Value is string route)
                            return route;
                        return null;
                    })
                    .FirstOrDefault() ?? controllerName;
                #endregion

                ClassDeclarationSyntax renamedClass = conDe
                    .WithIdentifier(SyntaxFactory.Identifier(cln))
                    .WithLeadingTrivia(conDe.GetLeadingTrivia())  // 保留原有前导空白/注释
                    .WithTrailingTrivia(conDe.GetTrailingTrivia()); // 保留原有后置空白/注释

                MethodDeclarationSyntax newMethod = SyntaxFactory.MethodDeclaration(
    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
    "Map").
    WithParameterList(SyntaxFactory.ParseParameterList("(Microsoft.AspNetCore.Builder.WebApplication app)"))
    .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword)))
    .WithBody(SyntaxFactory.Block(
        SyntaxFactory.ParseStatement(GenSub(kvp.Key, kvp.Value))));

                var fin = renamedClass.AddMembers(newMethod,SyntaxFactory.ParseMemberDeclaration($"string g_prefix = \"{prfx}\";"));
                foreach (var item in fin.Members.OfType<ConstructorDeclarationSyntax>())
                {
                    var newCtor = item.WithIdentifier(SyntaxFactory.Identifier(cln));
                    var c1 = fin.Members.Replace(item, newCtor);
                    fin = fin.WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(c1));
                }
                
                var o = fin.NormalizeWhitespace().ToFullString();
                /*$$"""
                //    {{modi}} class {{cln}} : {{baseTy}}
                //    {
                //        readonly string g_prefix = "{{prfx}}";
                                           
                //        {{modi}} void Map(Microsoft.AspNetCore.Builder.WebApplication app)
                //        {
                //            var grp = app.MapGroup(g_prefix);
                //            {{MapMethods(conDe.Members.OfType<MethodDeclarationSyntax>(), model)}}
                //        }
                //    }
                //    """*/
                sb.AppendLine(o);

            }
            return sb.ToString();
        }

        private string GenSub(ClassDeclarationSyntax renamedClass,SyntaxTree tree)
        {
            var model = context.Compilation.GetSemanticModel(tree);
            var sb = new StringBuilder();
            var c1 = "var grp = app.MapGroup(g_prefix);";
            sb.AppendLine(c1);
            foreach (var method in renamedClass.Members.OfType<MethodDeclarationSyntax>())
            {
                foreach (var attrls in method.AttributeLists)
                {

                    foreach (var attr in attrls.Attributes)
                    {
                        if (model.GetSymbolInfo(attr).Symbol is IMethodSymbol attributeCtorSymbol)
                        {
                            var attributeSymbol = attributeCtorSymbol.ContainingType;

                            var baseTypeSymbol = attributeSymbol.BaseType;

                            if (baseTypeSymbol.ToDisplayString() == "Microsoft.AspNetCore.Mvc.Routing.HttpMethodAttribute") 
                            {
                                if (attributeCtorSymbol.ToDisplayString().Contains("Get"))
                                {
                                    var c2 = $"grp.MapGet(\"/\",{method.Identifier});";
                                    sb.AppendLine(c2);
                                }
                            }
                        }

                    }
                }
            }
            return sb.ToString();
        }

        private string GenMinimalMapping(Dictionary<ClassDeclarationSyntax, SyntaxTree> controllers)
        {
            var sb = new StringBuilder();
            foreach (var clsN in g_clsN)
            {
                var st = $"new {clsN}().Map(app);";
                sb.AppendLine(st);
            }

            return sb.ToString();
            foreach (var kvp in controllers)
            {
                var controller = kvp.Key;
                var tree = kvp.Value; 
                var model = context.Compilation.GetSemanticModel(controllers[controller]);
                var controllerName = controller.Identifier.Text.Replace("Controller", "");
                var classSymbol = model.GetDeclaredSymbol(controller) as INamedTypeSymbol;

                // 解析 Controller 的 [Route]，默认为 controllerName
                string baseRoute = controller.AttributeLists
                    .SelectMany(al => al.Attributes)
                    .Where(attr =>
                    {
                        var sym = model.GetSymbolInfo(attr).Symbol as IMethodSymbol;
                        return sym?.ContainingType.ToDisplayString() == "Microsoft.AspNetCore.Mvc.RouteAttribute";
                    })
                    .Select(attr =>
                    {
                        var argExpr = attr.ArgumentList?.Arguments.FirstOrDefault()?.Expression;
                        var constVal = argExpr != null ? model.GetConstantValue(argExpr) : default;
                        if (constVal.HasValue && constVal.Value is string route)
                            return route;
                        return null;
                    })
                    .FirstOrDefault() ?? controllerName;

                // 处理特殊根路由 "/" 或空字符串的情况，保持为空字符串，方便拼接
                baseRoute = baseRoute.Trim('/');
                if (baseRoute == "/") baseRoute = "";

                foreach (var method in controller.Members.OfType<MethodDeclarationSyntax>())
                {
                    if (!method.Modifiers.Any(m => m.Text == "public")) continue;

                    var methodName = method.Identifier.Text;
                    bool isHttpGet = false;
                    string methodRoute = null;

                    // 解析方法上的 HttpGetAttribute
                    foreach (var attr in method.AttributeLists.SelectMany(a => a.Attributes))
                    {
                        var attrSym = model.GetSymbolInfo(attr).Symbol as IMethodSymbol;
                        var fullAttrName = attrSym?.ContainingType.ToDisplayString();

                        if (fullAttrName == "Microsoft.AspNetCore.Mvc.HttpGetAttribute")
                        {
                            isHttpGet = true;

                            if (attr.ArgumentList?.Arguments.Count > 0)
                            {
                                var constVal = model.GetConstantValue(attr.ArgumentList.Arguments[0].Expression);
                                if (constVal.HasValue && constVal.Value is string s)
                                    methodRoute = s;
                            }
                            break;
                        }
                    }
                    if (!isHttpGet) continue;

                    // 如果方法路由为空，用参数名自动生成路径，如 "{id}/{name}"
                    if (string.IsNullOrEmpty(methodRoute))
                    {
                        var parameters = method.ParameterList.Parameters;
                        if (parameters.Count > 0)
                        {
                            methodRoute = string.Join("/", parameters.Select(p => $"{{{p.Identifier.Text}}}"));
                        }
                        else
                        {
                            methodRoute = methodName;
                        }
                    }

                    // 拼接完整路由路径
                    var routeParts = new List<string>();
                    if (!string.IsNullOrEmpty(baseRoute)) routeParts.Add(baseRoute);
                    if (!string.IsNullOrEmpty(methodRoute)) routeParts.Add(methodRoute);
                    var finalRoute = "/" + string.Join("/", routeParts).Trim('/');

                    // 生成 Minimal API Lambda 的参数列表和调用参数列表
                    var lambdaParameters = method.ParameterList.Parameters.Select(p =>
                    {
                        var typeInfo = model.GetTypeInfo(p.Type);
                        var typeName = typeInfo.Type?.ToDisplayString() ?? p.Type.ToString();
                        return $"{typeName} {p.Identifier.Text}";
                    });
                    var lambdaParamsStr = string.Join(", ", lambdaParameters);
                    var methodArgsStr = string.Join(", ", method.ParameterList.Parameters.Select(p => p.Identifier.Text));

//                    sb.AppendLine($$"""
//app.MapGet("{{finalRoute}}", ({{lambdaParamsStr}}) => new {{classSymbol.ToDisplayString()}}().{{methodName}}({{methodArgsStr}}));
//""");
                }
            }

            return sb.ToString();
        }
        private HashSet<string> CollectAllUsings(Dictionary<ClassDeclarationSyntax, SyntaxTree> controllers)
        {
            var allUsings = new HashSet<string>();

            foreach (var kvp in controllers)
            {
                var classDecl = kvp.Key;
                var tree = kvp.Value;
                var root = tree.GetRoot() as CompilationUnitSyntax;

                // 1. 添加文件级别的 using
                foreach (var usingDirective in root?.Usings ?? Enumerable.Empty<UsingDirectiveSyntax>())
                {
                    if (usingDirective.Alias == null) // 忽略别名 using
                    {
                        allUsings.Add(usingDirective.Name.ToString());
                    }
                }

                // 2. 添加命名空间内的 using
                var parent = classDecl.Parent;
                while (parent != null)
                {
                    if (parent is NamespaceDeclarationSyntax namespaceDecl)
                    {
                        foreach (var usingDirective in namespaceDecl.Usings)
                        {
                            if (usingDirective.Alias == null)
                            {
                                allUsings.Add(usingDirective.Name.ToString());
                            }
                        }
                    }
                    parent = parent.Parent;
                }
            }

            return allUsings;
        }
        public void Initialize(GeneratorInitializationContext context)
        {

        }
    }
}
